STEPS TO CREATE PERSONAL ACCESS TOKEN (PAT)

Sign in to your github
Click on profile Picture (Profile buttun) -> Top right corner
Scroll down and Click Settings
On LHS of the new screen, scroll down and Click Developer Settings
On top LHS of the new screen Click PAT
Select tokens Classic
On Mid of the Screen, on the Top, Click Generate new TOKEN
Select Token Classic
Add a suitable Note
Expiration: NO Expiration
Leave the other things as it is, scroll down and Click Generate Token

Now, copy the Token and mail it to yourself. Or WhatsApp it to yourself. See that it is safely available to you always.


https://github.com/neelmyna/alliance_java

git clone https://ghp_M1122h1jSHuF6Ly1234yll8yqV0g41L2tPfZ6@github.com/neelmyna/alliance_java
---------------------------------------
public void myFunction() {
	Student student = new Student();
	
	int array[10];
	int[] array = new int[10];
	int[] array = new int[userSize];
}
---------------------------------------
public void myFunction() {
	Student student1 = new Student();
	Student student1 = new Student(101, "nithin", "comp-sc", 89.5f, 7, 9988554477L);
	Student student3 = new Student(s2);
}
---------------------------------------
CRUD operations RESTful API End Points
	findById() // get/id // select * from students where id = ?
	findAll() // get // select * from students
	create() // post // insert into students.....
	findBnyIdAndDelete() // delete // delete from students where id = ?
	findBnyIdAndUpdate() // put // update students set ? = ? where id = ?
---------------------------------------
Day4 06-10-2024

Linear Search
Binary Search
Bubble Sort
Insertion Sort
Merge Sort
BST (insertion, search and traversals, deletion)
Continuation of Mini Project (DB connectivity and CRUD operations)

LINEAR SEARCH
Given a list of elements, we search for an element sequentially or linearly.
The Scenarios:
1. The search element might be found at the very 1st position or very near to the 1st position.
2. The search element might be found at the very last position or some where near the last position.
3. The search element is not at all found.

BIG-OH NOTATION:
> It is usually used to find the worst case efficiency (WCE) of an algorithm.
> However it can be used to find the BCE also.
> It gives/finds the efficiency in terms of the input size N.
> It doesn't give us the exact efficiency, rather the purpose is to tell in what order the algorithm is. For example, logarthmic, square root, linear, quadratic, factorial etc.
> The Big-Oh considers the I/P size to be very very big.

We always will be knowing the I/P size N.

So we can use for loop.

for i from 1 to N do:
	if list[i] == searchElement
		return i // return i, the position where element is found
return -1 // -1 is to indicate that the element was not found.

The BCE of Linear search is O(1), that is, one unit of time is taken, becuase one unit of work is done.

The worst case scenario is when the element is not found. This conclusion we can make only when all the elements of the list/array are accessed (look up).
Thus the WCE of linear search is O(N)

There is one more case where we get O(N) efficiency. That is when the element is found at the last position or some where near to it.
------------------------------------------------------------
BINARY SEARCH:
Prerequisite: The I/P list must be sorted.

We start the search by moving to exactly the mid element in the list and check if the mid element is the search element.

If yes, then we got the element and stop.
If not, then we check if the key is smaller than the mid element,
	if yes, then set the search area to 1st half of the list
	else, we set the 2nd half of the list as search area.
Continue the above steps until a single element is left in the search area.

Read N
define array[N]
read Key
set low  = 0   // The start index
set high = N-1 // The last index
do:
	mid = (low + high) / 2  // see that is integer division only.
	if array[mid] == key then:
		return mid
	else if key < array[mid] then:
		high = mid - 1
	else
		low = mid + 1
-------------------------------------------------
package java_concepts;

import java.util.Arrays;
import java.util.Scanner;

public class BinarySearch {
	private int inputSize;
	private double[] array;
	private double searchKey;
	private static Scanner scanner;
	
	static {
		scanner = new Scanner(System.in);
	}
	
	public void readInputData() {
		System.out.print("Enter input size of the list: ");
		inputSize = scanner.nextInt();
		array = new double[inputSize];
		System.out.println("Enter " + inputSize + " numbers:");
		for(int i = 0; i < inputSize; i++)
			array[i] = scanner.nextDouble();
		Arrays.sort(array);
		System.out.println("User given List of numbers is \n" + Arrays.toString(array));
		System.out.print("Enter search element: ");
		searchKey = scanner.nextDouble();
	}
	
	public int binarySearch() {
		int low = 0;
		int high = inputSize-1;
		do {
			int mid = (low + high) / 2;
			if (array[mid] == searchKey)
				return mid;
			else if(searchKey < array[mid])
				high = mid-1;
			else
				low = mid+1;
		}while(low <= high); // until list has at least one element
		
		return -1; // Element not found
	}
	
	public static void main(String[] args) {
		BinarySearch ls = new BinarySearch();
		ls.readInputData();
		int keyIndex = ls.binarySearch();
		if(keyIndex == -1)
			System.out.println("Search element not found");
		else
			System.out.println("Search element found at position " + (keyIndex+1));
	}
}

EFFICIENCY OF BINARY SEARCH:
Note that, we find the efficiency in terms of the I/P size N
To do this, we must count the total number of iterations of the loop or nested loops we use.
However, in Binary search we use do-while loop and not the for loop.
Thus, we have no direct way to find the number of iterations.
Hence, we must find the number of iterations in an indirect way.

Let the number of ierations be X (un known value which we have find)
Because, the efficiency depends on X.
We know the number of elements in 1st iteration is N
And in every next iteration, the number of elements will be halved.
Thus the number of elements in all the iterations will be:

N          N/2      N/4      N/8  .......     4      2      1
2pow(X-1)								    2pow2  2pow1  2pow0
Thus,
N = 2pow(X) // Ignore the constants, because N is very very big
Hence X = Log(N)
Thus the WCE of Binary search is Log(N)
And of course, the BCE will be O(1)
------------------------------------------------------
SORTING:
> To sort any list of elements, we must access (look up) all elements from the unsorted array and keep placing one element at a time into the sorted array.
> Note that the unsorted array and the sorted array are within the same given array.
> Thus, the unsorted array keeps shrinking while sorted array keeps growing.
> In almost all the sorting algorithms (except Merge sort), the best case scenario/efficiency is when the list is already sorted and we too are sorting the list in the same order.
> In almost all the sorting algorithms (except Merge sort), the worst case scenario/efficiency is when the list is already sorted, but we are sorting the list in the reverse order.
> In the implementation of sorting algorithms, the outer loop always run to access the elements from the unsorted array
> The inner loops does the thing/job like, comparing the consecutive elements (Bubble sort), shifting the elements (insertion sort), finding the index/position of current element (selection sort) etc.

BUBBLE SORT:
> We start from any one of the 2 corners/ends of the unsorted array. Usually from the front end of the array
> We compare the consecutive elements of the array and swap the elements if the 1st element is bigger than the 2nd (Assuming we are sorting in increasing order)
> We continue to compare the consecutive elements until end of the unsorted array. Thus we bubble/push the ith biggest element to its final position.
> Bubble sort is very typical nature, meaning it is very simple to use. Thus readability is easy.
> However, Bubble sort has no intelligent idea/step to predict the I/P list elements.
> This is because, even in the case where the I/P list is fully sorted, the Bubble sort algorithm does the same number comparisons or all comparisons when the list is not sorted or need to be sorted in reverse order of the I/P sorted list.
> The outer loop access elements from the unsorted array while the inner loop compares the consecutive elements in the unsorted array.
> In the worst case scenario, we find the maximum possible number of swaps to happen.
> In the best case scenario, the number of swaps in every iteration of the outer loop will be zero.
> Thus, when we find that there are no swaps for an iteration of the outer loop (placing one element in its final position. Thus the element is already in its final position and thus we also get to know that there is no need move any of the remaining elements of the unsorted array), we can stop the sorting as the array is by now fully sorted.
> Thus by adding a small condition to check if there were no swaps, we can optimise the WCE of Bubble sort from O(N square) which is quadratic to O(N) which is linear.

Without Optimization,
WCE = O(N square)
ACE = O(N square)
BCE = O(N square)

After optimization,
WCE = O(N square)
ACE = O(N square)
BCE = O(N)
----------------------
Pseudocode:
